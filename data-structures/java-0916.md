# Array
- class
    - bc all falls into primitive or class
- uses "new", so therefore definitely class
- can be array of `primitive` or `object`
    - if array of primitive
    - declare: `int []array = new integer[32];` 
    - `int[] array, tmp`
        - array is type array
        - tmp is type int
        - if declare multiple variables if comma separated array doesn't apply to both
    - `int []array, tmp`
        - better
        - `int array[]` - same thing
    
- `int []array = new int[32]`
- MyObject []arr
- `null pointer`
    - java compiler writte in C++
    - when get null pointer, like reference array that doesnt exist, will get
    - haven't assigned object to place in memory for array
- array of objects builds the arrray, doesn't allocate
- `new int[32]` - memory is allocated
- custom object, need to allocate memory len + 1
    - 1 for each item, 1 for variable
- `arr[0]` - null
    - then allocate to somewhere in memory: RAM
- `arr[1]` - null
- `arr[2]` - null
- `arr[3]` - null

- `MyObject: F3a912`
    - `handle` - LEARN ABOUT
    - table of handles
        - memorry exists until closing brace of whatever declares it
            - memory returned back to memory pool
- `reference counting`
    - how memory is managed
    - allocate an object: `MyObject = new MyObject();`
        - looks like calling constructor, but is not
            - memory is allocated, then constructor is called.
            - assigns handle to this object MyObject
            - if all is memory is full, constructor never gets called
                - bc failed during memory allocation
            - is `atomic` - isn't interuptable
        - goes out into HEAP
        - allocates from HEAP and assigns to object
        - there is memory on STACK, HEAP, and static memory
- `handle and reference counting`
    - when `MyObject x = new MyObject();`
        - when create new object, `reference couter` gets set to 1
    - when `MyObject tmp = x;`
        - when create new object, reference couter gets set to 2
    - `when reference cout hits zero, garbage collector cleans up`

- `gargage collector`
    - is method, can call `gc();`
    - `System.gc();`
- `dynamic memory` - gc deals with 
    - comes in when using `new`
    - arrays use `new` - so use dynamic memory
- `static`
    - a variable belongs to the class, not any instantiation
- `Locker x = new Locker()`
- can create static public getter method to get private static int
    - moving away from this towards `Locker x = Lockers.getInstance();`
        - must be static because not calling new
        - must be public because calling from outside Locker class
        - looks like: `public static Locker getInstance(){if lockersAvail > 0 {return new Locker();} else {rerturn null;}}`